//
//  FHSyncUtils.m
//  FH
//
//  Created by Wei Li on 16/07/2013.
//  Copyright (c) 2013 FeedHenry. All rights reserved.
//

#import "FHSyncUtils.h"
#import "JSONKit.h"
#import <CommonCrypto/CommonDigest.h>
#import "FHSyncClient.h"
#import "FHSyncNotificationMessage.h"

@implementation FHSyncUtils

+ (NSString*) getStorageFilePath:(NSString*) fileName
{
  NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentationDirectory, NSUserDomainMask, YES);
  NSString *documentsDir = [paths objectAtIndex:0];
  if(![[NSFileManager defaultManager] fileExistsAtPath:documentsDir]){
    [[NSFileManager defaultManager] createDirectoryAtPath:documentsDir withIntermediateDirectories:YES attributes:nil error:nil];
  }
  NSString *storageFilePath = [documentsDir stringByAppendingPathComponent:fileName];
  NSLog(@"file path is %@", storageFilePath);
  return storageFilePath;
}


+ (NSString*) loadDataFromFile: (NSString*) fileName error:(NSError*) error;
{
  NSString* storageFilePath = [FHSyncUtils getStorageFilePath: fileName];
  NSString * fileContent = nil;
  BOOL fileExists = [[NSFileManager defaultManager] fileExistsAtPath:storageFilePath];
  if (fileExists) {
    fileContent = [NSString stringWithContentsOfFile:storageFilePath encoding:NSUTF8StringEncoding error:&error];
    if (error){
      NSLog(@"Failed to read file content from file : %@ with error %@", storageFilePath, [error localizedDescription] );
    }
  }
  return fileContent;
}

+ (void) saveData: (NSString*) data toFile:(NSString* ) fileName error:(NSError*) error
{
  NSString* filePath = [FHSyncUtils getStorageFilePath:fileName];
  if(![[NSFileManager defaultManager] fileExistsAtPath:filePath]){
    [[NSFileManager defaultManager] createFileAtPath:filePath contents:[data dataUsingEncoding:NSUTF8StringEncoding] attributes:nil];
  } else {
    [data writeToFile:filePath atomically:YES encoding:NSUTF8StringEncoding error:&error];
    if(error){
      NSLog(@"Failed to write data to file at path %@ with error %@", filePath, [error localizedDescription]);
    }
  }

}

+ (NSString*) generateHashWithString: (NSString*) text
{
  NSData * data = [text dataUsingEncoding:NSUTF8StringEncoding];
  uint8_t digest[CC_SHA1_DIGEST_LENGTH];
  
  CC_SHA1(data.bytes, data.length, digest);
  
  NSMutableString *output = [NSMutableString stringWithCapacity:CC_SHA1_DIGEST_LENGTH * 2];
  
  for (int i = 0; i < CC_SHA1_DIGEST_LENGTH; i++)
  {
    [output appendFormat:@"%02x", digest[i]];
  }
  
  return output;
}

+ (id) sortData: (id) data
{
  if (nil == data || (![data isKindOfClass:[NSDictionary class]] && ![data isKindOfClass:[NSArray class]])){
    return data;
  }
  
  NSMutableArray* results = [NSMutableArray array];
  if([data isKindOfClass:[NSDictionary class]]){
    NSArray * keys = [(NSDictionary *)data allKeys];
    NSArray* sortedKeys = [keys sortedArrayUsingSelector:@selector(localizedCaseInsensitiveCompare:)];
    for (int i=0;i<sortedKeys.count; i++) {
      NSString* key = [sortedKeys objectAtIndex:i];
      id value = [data objectForKey:key];
      NSMutableDictionary* record = [NSMutableDictionary dictionary];
      [record setObject:key forKey:@"key"];
      [record setObject:[FHSyncUtils sortData:value] forKey:@"value"];
      [results addObject:record];
    }

  } else if([data isKindOfClass:[NSArray class]]){
    for(int i=0;i<[data count];i++){
      NSMutableDictionary* record = [NSMutableDictionary dictionary];
      [record setObject: [NSString stringWithFormat:@"%d", i] forKey:@"key"];
      [record setObject:[FHSyncUtils sortData: [data objectAtIndex:i]] forKey:@"value"];
      [results addObject:record];
    }
  }
  return results;
}

/** We have to make sure the hash value generated by this method will result the same value as the function in JS SDK **/
+ (NSString*) generateHashForData:(id) data
{
  id results = [FHSyncUtils sortData:data];
  NSString* jsonStr = [results JSONString];
  NSLog(@"sorted data = %@", jsonStr);
  return [FHSyncUtils generateHashWithString:jsonStr];
}

+ (void) doNotifyWithDataId:(NSString*) dataId config:(FHSyncConfig*) config uid:(NSString*) uid code:(NSString*) code message:(NSString*) message
{
  BOOL doSend = NO;
  if(config.notifySyncStarted && [code isEqualToString:SYNC_STARTED_MESSAGE]){
    doSend = YES;
  }
  if(config.notifySyncCompleted && [code isEqualToString:SYNC_COMPLETE_MESSAGE]) {
    doSend = YES;
  }
  if(config.notifyClientStorageFailed && [code isEqualToString:CLIENT_STORAGE_FAILED_MESSAGE]){
    doSend = YES;
  }
  if(config.notifyDeltaReceived && [code isEqualToString:DELTA_RECEIVED_MESSAGE ]){
    doSend = YES;
  }
  if(config.notifyOfflineUpdate && [code isEqualToString:OFFLINE_UPDATE_MESSAGE]){
    doSend = YES;
  }
  if(config.notifySyncCollision && [code isEqualToString:COLLISION_DETECTED_MESSAGE]){
    doSend = YES;
  }
  if(config.notifyRemoteUpdateApplied && [code isEqualToString:REMOTE_UPDATE_APPLIED_MESSAGE]){
    doSend = YES;
  }
  if(config.notifyRemoteUpdateFailed && [code isEqualToString:REMOTE_UPDATE_FAILED_MESSAGE]){
    doSend = YES;
  }
  if(config.notifyRemoteUpdateApplied && [code isEqualToString:LOCAL_UPDATE_APPLIED_MESSAGE]){
    doSend = YES;
  }
  if(config.notifySyncFailed && [code isEqualToString:SYNC_FAILED_MESSAGE]){
    doSend = YES;
  }
  if(doSend){
    FHSyncNotificationMessage * notification = [[FHSyncNotificationMessage alloc] initWithDataId:dataId AndUID:uid AndCode:code AndMessage:message];
    [[NSNotificationCenter defaultCenter] postNotificationName:kFHSyncStateChangedNotification object:notification];
  }
}


@end
